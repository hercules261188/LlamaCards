<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LlamaCards</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e1e1e;
            color: #ffffff;
            user-select: none;
            overflow: hidden;
        }

        #app {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 200px;
            background-color: #252526;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
        }

        #main {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab;
            overflow: hidden;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 10000px;
            height: 10000px;
            transform-origin: 0 0;
        }

        #connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .card {
            background-color: #333333;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            padding: 15px;
            margin-bottom: 15px;
            position: absolute;
            width: 225px;
            z-index: 2;
            resize: both;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            border-bottom: 2px solid #ffffff;
            cursor: grab;
            border-radius: 8px 8px 0 0;
            background-color: #1e1e1e;
        }

        .card-header.llm {
            background-color: #004060;
        }

        .card-header.prompt {
            background-color: #7a3d00;
        }

        .card-title {
            font-weight: bold;
        }

        .card-body {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
            user-select: text;
        }

        .connection-point {
            width: 0;
            height: 0;
            border-style: solid;
            cursor: pointer;
            position: absolute;
            z-index: 3;
        }

        .input-point {
            border-width: 8px 8px 8px 0;
            border-color: transparent #d9534f transparent transparent;
        }

        .output-point {
            border-width: 8px 0 8px 8px;
            border-color: transparent transparent transparent #007acc;
        }

        .top-input-point {
            top: -4px;
            left: 48%;
            transform: translateX(-50%) rotate(-90deg);
        }

        .top-output-point {
            top: -4px;
            left: 52%;
            transform: translateX(-50%) rotate(-90deg);
        }

        .bottom-input-point {
            bottom: -4px;
            left: 52%;
            transform: translateX(-50%) rotate(90deg);
        }

        .bottom-output-point {
            bottom: -4px;
            left: 48%;
            transform: translateX(-50%) rotate(90deg);
        }

        .left-input-point {
            left: -0px;
            top: 52%;
            transform: translateY(-50%) rotate(180deg);
        }

        .left-output-point {
            left: -0px;
            top: 48%;
            transform: translateY(-50%) rotate(180deg);
        }

        .right-input-point {
            right: -0px;
            top: 48%;
            transform: translateY(-50%) rotate(0deg);
        }

        .right-output-point {
            right: -0px;
            top: 52%;
            transform: translateY(-50%);
        }

        textarea,
        .response-area,
        input {
            width: 100%;
            background-color: #3c3c3c;
            color: #ffffff;
            border: 1px solid #555;
            box-sizing: border-box;
        }

        .prompt-area {
            height: 37.5px;
        }

        .response-area {
            height: 75px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .response-area pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
        }

        button,
        select {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover,
        select:hover {
            background-color: #1177bb;
        }

        .resize-button {
            width: 15px;
            height: 15px;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: se-resize;
            background-color: #ffffff;
        }

        .context-menu {
            position: absolute;
            background-color: #3c3c3c;
            border: 1px solid #555;
            padding: 5px 0;
            z-index: 1000;
        }

        .context-menu-item {
            padding: 5px 20px;
            cursor: pointer;
        }

        .context-menu-item:hover {
            background-color: #4c4c4c;
        }

        @keyframes highlight {
            0% {
                box-shadow: 0 0 5px 5px rgba(0, 122, 204, 0.5);
            }

            50% {
                box-shadow: 0 0 15px 15px rgba(0, 122, 204, 0.5);
            }

            100% {
                box-shadow: 0 0 5px 5px rgba(0, 122, 204, 0.5);
            }
        }

        .card.processing {
            animation: highlight 0.75s infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -5;
            }
        }

        .connection {
            stroke: #007acc;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5, 5;
            animation: dash 0.25s linear infinite;
        }

        .bottom-controls {
            margin-top: auto;
            padding: 10px;
            border-top: 1px solid #555;
            background-color: #1e1e1e;
            position: relative;
        }

        .layout-list-container {
            border: 1px solid #555;
            border-radius: 4px;
            padding: 10px;
            background-color: #2e2e2e;
            max-height: 150px;
            overflow-y: auto;
        }

        .layout-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .layout-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
        }

        .layout-list-item span {
            flex-grow: 1;
        }

        .layout-list-item button {
            background-color: #d9534f;
            margin-left: 5px;
        }

        .layout-list-item button:hover {
            background-color: #c9302c;
        }

        .footer-text {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #ffffff;
            font-size: 12px;
            z-index: 1000;
        }

        #sidebar-settings-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            cursor: pointer;
        }

        #settings-popup,
        #endpoint-popup,
        #card-settings-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            padding: 20px;
            border: 1px solid #555;
            z-index: 10000;
        }

        #settings-popup h3,
        #endpoint-popup h3,
        #card-settings-popup h3 {
            margin-top: 0;
        }

        .gear-icon {
            width: 20px;
            height: 20px;
            cursor: pointer;
            margin-left: auto;
        }

        .default-context-size-container {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <div id="sidebar-settings-icon" class="gear-icon" onclick="showSettingsPopup()">âš™</div>
            <h2>LlamaCards</h2>
            <button onclick="clearTable()">Clear Table</button>
            <button onclick="clearCardContent()">Clear Card Content</button>
            <div class="bottom-controls">
                <button onclick="showSaveLayoutPopup()">Save Layout</button>
                <div id="save-layout-popup" style="display: none;">
                    <input type="text" id="layout-name" placeholder="Enter layout name">
                    <button onclick="saveLayout()">Save</button>
                </div>
                <div class="layout-list-container">
                    <ul id="layout-list" class="layout-list"></ul>
                </div>
            </div>
        </div>
        <div id="main">
            <div id="canvas-container">
                <div id="canvas">
                    <svg id="connections"></svg>
                </div>
            </div>
            <div class="footer-text">LlamaCards by Cory Hafer</div>
        </div>
    </div>

    <div id="context-menu" class="context-menu" style="display: none;">
        <div class="context-menu-item" onclick="createCard(event, 'llm')">LLM Card</div>
        <div class="context-menu-item" onclick="createCard(event, 'prompt')">Prompt Card</div>
    </div>

    <div id="settings-popup">
        <h3>Settings</h3>
        <label for="default-model-select">Default Model:</label>
        <select id="default-model-select" onchange="saveDefaultModel()"></select>
        <br>
        <hr>
        <label for="default-context-size-slider">Default Context Size:</label>
        <input type="range" id="default-context-size-slider" min="2048" max="131072" step="1024" value="2048" oninput="updateContextSizeDisplay(this.value)">
        <span id="context-size-display">2048</span>
        <br>
        <hr>
        <label for="enable-default-context-size"> Enable Default Context Size</label>
        <input type="checkbox" id="enable-default-context-size" onchange="saveDefaultContextSize()">
        <br>
        <hr>
        <label for="endpoint-input">Ollama Endpoint:</label>
        <input type="text" id="endpoint-input" value="http://localhost:5000">
        <br>
        <button onclick="saveSettings()">Save</button>
        <button onclick="closeSettingsPopup()">Cancel</button>
    </div>

    <div id="card-settings-popup">
        <h3>Card Settings</h3>
        <label for="context-size-slider">Context Size:</label>
        <input type="range" id="context-size-slider" min="2048" max="131072" step="1024" value="2048" oninput="updateCardContextSizeDisplay(this.value)">
        <span id="card-context-size-display">2048</span>
        <br>
        <button onclick="saveCardSettings()">Save</button>
        <button onclick="closeCardSettingsPopup()">Cancel</button>
    </div>

    <script>
        let cards = [];
        let connections = [];
        let draggedPoint = null;
        let zoom = 1;
        let isPanning = false;
        let startX, startY, offsetX = 0,
            offsetY = 0;
        const connectionsSVG = document.getElementById('connections');
        const main = document.getElementById('main');
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('canvas');
        const contextMenu = document.getElementById('context-menu');
        let currentSettingsCard = null;
        let ollamaEndpoint = getCookie('ollamaEndpoint') || 'http://192.168.0.27:11434';
        let modelList = [];
        let defaultModel = getCookie('defaultModel') || '';
        let defaultContextSize = getCookie('defaultContextSize') || 2048;
        let enableDefaultContextSize = getCookie('enableDefaultContextSize') === 'true';

        async function fetchModels() {
            try {
                const response = await fetch('/api/models');
                if (response.ok) {
                    modelList = await response.json();
                    updateModelDropdowns();
                    updateDefaultModelDropdown();
                } else {
                    console.error('Failed to fetch models');
                }
            } catch (error) {
                console.error('Error fetching models:', error);
            }
        }

        function updateModelDropdowns() {
            const selects = document.querySelectorAll('select[id^="modelSelect"]');
            selects.forEach(select => {
                const currentModel = select.value;
                select.innerHTML = '';
                modelList.forEach(model => {
                    if (model !== 'NAME') {
                        const option = document.createElement('option');
                        option.value = model;
                        option.text = model;
                        if (model === currentModel || model === defaultModel) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    }
                });
            });
        }

        function updateDefaultModelDropdown() {
            const defaultModelSelect = document.getElementById('default-model-select');
            defaultModelSelect.innerHTML = '';
            modelList.forEach(model => {
                if (model !== 'NAME') {
                    const option = document.createElement('option');
                    option.value = model;
                    option.text = model;
                    if (model === defaultModel) {
                        option.selected = true;
                    }
                    defaultModelSelect.appendChild(option);
                }
            });
        }

        function saveDefaultModel() {
            const defaultModelSelect = document.getElementById('default-model-select');
            defaultModel = defaultModelSelect.value;
            setCookie('defaultModel', defaultModel, 365);
            updateModelDropdowns();
        }

        function saveDefaultContextSize() {
            const enableDefaultContextSizeCheckbox = document.getElementById('enable-default-context-size');
            enableDefaultContextSize = enableDefaultContextSizeCheckbox.checked;
            setCookie('enableDefaultContextSize', enableDefaultContextSize, 365);

            const defaultContextSizeSlider = document.getElementById('default-context-size-slider');
            defaultContextSize = defaultContextSizeSlider.value;
            setCookie('defaultContextSize', defaultContextSize, 365);
        }

        function createCard(event, type) {
            const card = document.createElement('div');
            card.className = 'card';
            const canvasRect = canvas.getBoundingClientRect();
            card.style.left = `${(event.clientX - canvasRect.left) / zoom}px`;
            card.style.top = `${(event.clientY - canvasRect.top) / zoom}px`;
            card.dataset.inputsReceived = 0;
            card.dataset.expectedInputs = 0;
            card.dataset.responses = '';
            let cardContent = '';

            switch (type) {
                case 'llm':
                    card.dataset.model = defaultModel || (modelList[0] && modelList[0] !== 'NAME' ? modelList[0] : '');
                    card.dataset.prompt = '';
                    card.dataset.message = '';
                    card.dataset.contextSize = enableDefaultContextSize ? defaultContextSize : 2048; // Default context size
                    cardContent = `
                        <div class="card-header llm" onmousedown="startDragCard(event, this)">
                            <span class="card-title">LLM Card ${cards.length + 1}</span>
                            <div class="gear-icon" onclick="showCardSettingsPopup(this.parentNode.parentNode)">âš™</div>
                            <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                        </div>
                        <div class="card-body">
                            <label for="modelSelect${cards.length}">Model</label>
                            <select id="modelSelect${cards.length}" onchange="updateCardModel(this)">
                                ${modelList.map(model => model !== 'NAME' ? `<option value="${model}" ${model === card.dataset.model ? 'selected' : ''}>${model}</option>` : '').join('')}
                            </select>
                            <textarea class="prompt-area" placeholder="Enter prompt" onchange="updateCardPrompt(this)"></textarea>
                            <textarea class="message-area" placeholder="Enter your message"></textarea>
                            <button onclick="sendMessage(this.parentNode.parentNode)">Send</button>
                            <div class="response-area"></div>
                        </div>`;
                    break;
                case 'prompt':
                    cardContent = `
                        <div class="card-header prompt" onmousedown="startDragCard(event, this)">
                            <span class="card-title">Prompt Card ${cards.length + 1}</span>
                            <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                        </div>
                        <div class="card-body">
                            <input type="text" class="prompt-input" placeholder="Enter prompt">
                            <input type="text" class="message-input" placeholder="Enter message">
                            <button onclick="sendPrompt(this.parentNode.parentNode)">Send</button>
                        </div>`;
                    break;
            }

            card.innerHTML = cardContent;
            card.innerHTML += `
                <div class="connection-point input-point top-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point output-point top-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point input-point bottom-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point output-point bottom-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point input-point left-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point output-point left-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point input-point right-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point output-point right-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                <div class="resize-button" onmousedown="startResize(event, this)"></div>`;
            canvas.appendChild(card);
            cards.push(card);
            updateExpectedInputs();
            hideContextMenu();
        }

        function clearTable() {
            cards.forEach(card => card.remove());
            cards = [];
            connections = [];
            connectionsSVG.innerHTML = '';
        }

        function clearCardContent() {
            cards.forEach(card => {
                const responseArea = card.querySelector('.response-area');
                if (responseArea) {
                    responseArea.innerHTML = '';
                }
            });
        }

        function updateExpectedInputs() {
            cards.forEach(card => {
                card.dataset.expectedInputs = connections.filter(conn => conn.to.closest('.card') === card).length;
            });
        }

        function updateCardModel(select) {
            const card = select.closest('.card');
            card.dataset.model = select.value;
        }

        function updateCardPrompt(textarea) {
            const card = textarea.closest('.card');
            card.dataset.prompt = textarea.value;
        }

        function removeCard(card) {
            connections = connections.filter(conn => conn.from.closest('.card') !== card && conn.to.closest('.card') !== card);
            cards = cards.filter(c => c !== card);
            card.remove();
            updateExpectedInputs();
            drawConnections();
        }

        function startDragCard(event, header) {
            event.stopPropagation();
            const card = header.parentElement;
            isDraggingCard = true;
            currentDraggedCard = card;
            startX = event.clientX - card.offsetLeft * zoom;
            startY = event.clientY - card.offsetTop * zoom;

            document.addEventListener('mousemove', dragCard);
            document.addEventListener('mouseup', stopDragCard);
        }

        function dragCard(event) {
            if (!isDraggingCard) return;
            const newX = (event.clientX - startX) / zoom;
            const newY = (event.clientY - startY) / zoom;
            currentDraggedCard.style.left = `${newX}px`;
            currentDraggedCard.style.top = `${newY}px`;
            drawConnections();
        }

        function stopDragCard() {
            isDraggingCard = false;
            currentDraggedCard = null;
            document.removeEventListener('mousemove', dragCard);
            document.removeEventListener('mouseup', stopDragCard);
        }

        function startDrag(event, type) {
            event.stopPropagation();
            event.preventDefault();
            draggedPoint = {
                element: event.target,
                type: type
            };
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
        }

        function drag(event) {
            if (!draggedPoint) return;
            drawConnections(event.clientX, event.clientY);
        }

        function stopDrag(event) {
            if (!draggedPoint) return;
            const targetPoint = findTargetPoint(event);
            if (targetPoint && targetPoint.type === 'input' && draggedPoint.type === 'output') {
                const connection = {
                    from: draggedPoint.element,
                    to: targetPoint.element
                };
                connections.push(connection);
                updateExpectedInputs();
            }
            draggedPoint = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
            drawConnections();
        }

        function disconnectDot(event, element) {
            event.stopPropagation();
            connections = connections.filter(conn => conn.from !== element && conn.to !== element);
            updateExpectedInputs();
            drawConnections();
        }

        function findTargetPoint(event) {
            const points = document.querySelectorAll('.connection-point');
            for (const point of points) {
                const rect = point.getBoundingClientRect();
                if (event.clientX >= rect.left && event.clientX <= rect.right &&
                    event.clientY >= rect.top && event.clientY <= rect.bottom) {
                    return {
                        element: point,
                        type: point.classList.contains('input-point') ? 'input' : 'output'
                    };
                }
            }
            return null;
        }

        function drawConnections(tempX, tempY) {
            connectionsSVG.innerHTML = '';

            for (const conn of connections) {
                const fromRect = conn.from.getBoundingClientRect();
                const toRect = conn.to.getBoundingClientRect();
                const startX = (fromRect.left + fromRect.width / 2 - canvas.getBoundingClientRect().left) / zoom;
                const startY = (fromRect.top + fromRect.height / 2 - canvas.getBoundingClientRect().top) / zoom;
                const endX = (toRect.left + toRect.width / 2 - canvas.getBoundingClientRect().left) / zoom;
                const endY = (toRect.top + toRect.height / 2 - canvas.getBoundingClientRect().top) / zoom;

                drawBezierCurve(startX, startY, endX, endY);
            }

            if (draggedPoint && tempX !== undefined && tempY !== undefined) {
                const rect = draggedPoint.element.getBoundingClientRect();
                const startX = (rect.left + rect.width / 2 - canvas.getBoundingClientRect().left) / zoom;
                const startY = (rect.top + rect.height / 2 - canvas.getBoundingClientRect().top) / zoom;
                drawBezierCurve(startX, startY, (tempX - canvas.getBoundingClientRect().left) / zoom, (tempY - canvas.getBoundingClientRect().top) / zoom);
            }
        }

        function drawBezierCurve(startX, startY, endX, endY) {
            const controlPoint1X = startX + (endX - startX) / 3;
            const controlPoint1Y = startY;
            const controlPoint2X = startX + 2 * (endX - startX) / 3;
            const controlPoint2Y = endY;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M${startX},${startY} C${controlPoint1X},${controlPoint1Y} ${controlPoint2X},${controlPoint2Y} ${endX},${endY}`);
            path.setAttribute('class', 'connection');
            connectionsSVG.appendChild(path);
        }

        async function sendMessage(card) {
            const textarea = card.querySelector('.message-area');
            if (textarea) {
                const message = textarea.value.trim();
                if (message) {
                    await processCardMessage(card, message);
                    textarea.value = '';
                }
            }
        }

        async function processCardMessage(card, message, processedCards = new Set()) {
            if (processedCards.has(card)) {
                // Allow continuous loop
            }
            processedCards.add(card);

            const model = card.dataset.model || '';
            const prompt = card.dataset.prompt || '';
            const contextSize = enableDefaultContextSize ? defaultContextSize : (card.dataset.contextSize || 2048); // Use the defined context size
            let combinedInput = `${prompt}${message}`;

            card.classList.add('processing');
            try {
                const response = await queryOllama(model, combinedInput, contextSize);
                let finalResponse = extractMessageContent(response);
                if (finalResponse) {
                    streamResponse(card, finalResponse);
                }
                card.classList.remove('processing');

                const connectedCards = connections
                    .filter(conn => conn.from.closest('.card') === card)
                    .map(conn => conn.to.closest('.card'));

                if (connectedCards.length > 0) {
                    await Promise.all(connectedCards.map(async nextCard => {
                        nextCard.dataset.inputsReceived++;
                        nextCard.dataset.responses += finalResponse + '\n';
                        if (parseInt(nextCard.dataset.inputsReceived, 10) >= parseInt(nextCard.dataset.expectedInputs, 10)) {
                            const combinedResponse = nextCard.dataset.responses.trim();
                            nextCard.dataset.responses = '';
                            nextCard.dataset.inputsReceived = 0;
                            await processCardMessage(nextCard, combinedResponse, processedCards);
                        }
                    }));
                }
            } catch (error) {
                console.error('Error processing message:', error);
                streamResponse(card, `Error: Unable to process message. Error details: ${error.message}`);
                card.classList.remove('processing');
            }
        }

        async function queryOllama(model, input, contextSize) {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: model,
                    messages: [{
                        role: 'user',
                        content: input
                    }],
                    stream: false,
                    context_size: contextSize,
                    endpoint: ollamaEndpoint // Pass the endpoint here
                }),
            });

            if (!response.ok) {
                throw new Error('Failed to get response from Ollama');
            }

            const responseData = await response.json();
            return JSON.stringify(responseData);
        }

        function streamResponse(card, response) {
            const outputArea = card.querySelector('.response-area');
            if (outputArea) {
                outputArea.innerHTML += `<pre>${response}</pre>`;
                outputArea.scrollTop = outputArea.scrollHeight;
            }
        }

        function extractMessageContent(response) {
            try {
                const parsedResponse = JSON.parse(response);
                if (parsedResponse.message && parsedResponse.message.content) {
                    return parsedResponse.message.content;
                }
            } catch (error) {
                console.error('Error parsing JSON:', error);
            }
            return null;
        }

        function sendPrompt(card) {
            const promptInput = card.querySelector('.prompt-input');
            const messageInput = card.querySelector('.message-input');
            if (promptInput && messageInput) {
                const prompt = promptInput.value.trim();
                const message = messageInput.value.trim();
                if (prompt || message) {
                    forwardPrompt(card, prompt, message);
                }
            }
        }

        function forwardPrompt(card, prompt, message) {
            const connectedCards = connections
                .filter(conn => conn.from.closest('.card') === card)
                .map(conn => conn.to.closest('.card'));

            connectedCards.forEach(nextCard => {
                if (prompt) {
                    nextCard.dataset.prompt = prompt;
                    const promptArea = nextCard.querySelector('.prompt-area');
                    if (promptArea) {
                        promptArea.value = prompt;
                    }
                }
                if (message) {
                    nextCard.dataset.message = message;
                    const messageArea = nextCard.querySelector('.message-area');
                    if (messageArea) {
                        messageArea.value = message;
                    }
                }
                sendMessage(nextCard);
            });
        }

        function zoomIn() {
            zoom *= 1.1;
            applyZoom();
        }

        function zoomOut() {
            zoom /= 1.1;
            applyZoom();
        }

        function applyZoom() {
            canvas.style.transform = `scale(${zoom})`;
            drawConnections();
        }

        function showContextMenu(event) {
            event.preventDefault();
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
        }

        function hideContextMenu() {
            contextMenu.style.display = 'none';
        }

        function startResize(event, resizeButton) {
            event.stopPropagation();
            const card = resizeButton.closest('.card');
            const startWidth = card.offsetWidth;
            const startHeight = card.offsetHeight;
            const startX = event.clientX;
            const startY = event.clientY;

            function resize(event) {
                const newWidth = startWidth + (event.clientX - startX);
                const newHeight = startHeight + (event.clientY - startY);
                card.style.width = `${newWidth}px`;
                card.style.height = `${newHeight}px`;

                const responseArea = card.querySelector('.response-area');
                if (responseArea) {
                    responseArea.style.height = `${newHeight - 112.5}px`;
                }

                drawConnections();
            }

            function stopResize() {
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', stopResize);
            }

            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
        }

        function showCardSettingsPopup(card) {
            currentSettingsCard = card;
            const contextSize = card.dataset.contextSize || 2048;
            document.getElementById('context-size-slider').value = contextSize;
            document.getElementById('card-context-size-display').innerText = contextSize;
            document.getElementById('card-settings-popup').style.display = 'block';
        }

        function showSettingsPopup() {
            document.getElementById('default-model-select').value = defaultModel;
            document.getElementById('default-context-size-slider').value = defaultContextSize;
            document.getElementById('context-size-display').innerText = defaultContextSize;
            document.getElementById('enable-default-context-size').checked = enableDefaultContextSize;
            document.getElementById('endpoint-input').value = ollamaEndpoint; // Set the endpoint input value
            document.getElementById('settings-popup').style.display = 'block';
        }

        function closeSettingsPopup() {
            document.getElementById('settings-popup').style.display = 'none';
            currentSettingsCard = null;
        }

        function closeCardSettingsPopup() {
            document.getElementById('card-settings-popup').style.display = 'none';
            currentSettingsCard = null;
        }

        async function saveSettings() {
            saveDefaultModel();
            saveDefaultContextSize();
            await saveEndpoint(); // Save endpoint changes
            closeSettingsPopup();
        }

        function saveCardSettings() {
            if (currentSettingsCard) {
                const contextSize = document.getElementById('context-size-slider').value;
                currentSettingsCard.dataset.contextSize = contextSize;
            }
            closeCardSettingsPopup();
        }

        function updateContextSizeDisplay(value) {
            document.getElementById('context-size-display').innerText = value;
        }

        function updateCardContextSizeDisplay(value) {
            document.getElementById('card-context-size-display').innerText = value;
        }

        function showEndpointPopup() {
            document.getElementById('endpoint-input').value = ollamaEndpoint;
            document.getElementById('endpoint-popup').style.display = 'block';
        }

        function closeEndpointPopup() {
            document.getElementById('endpoint-popup').style.display = 'none';
        }

        async function saveEndpoint() {
            const newEndpoint = document.getElementById('endpoint-input').value.trim();
            if (newEndpoint) {
                ollamaEndpoint = newEndpoint;
                setCookie('ollamaEndpoint', ollamaEndpoint, 365);
                try {
                    const response = await fetch('/api/update-endpoint', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ endpoint: ollamaEndpoint }),
                    });
                    if (!response.ok) {
                        throw new Error('Failed to update endpoint on server');
                    }
                } catch (error) {
                    console.error('Error updating endpoint on server:', error);
                }
                fetchModels();
                closeEndpointPopup();
            }
        }

        function initialize() {
            window.addEventListener('resize', () => {
                drawConnections();
            });
            main.addEventListener('contextmenu', showContextMenu);
            document.addEventListener('click', hideContextMenu);

            canvasContainer.addEventListener('mousedown', (e) => {
                if (e.target.closest('.card')) return;
                isPanning = true;
                startX = e.clientX - offsetX;
                startY = e.clientY - offsetY;
                canvasContainer.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                offsetX = e.clientX - startX;
                offsetY = e.clientY - startY;
                canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoom})`;
                drawConnections();
            });

            document.addEventListener('mouseup', () => {
                isPanning = false;
                canvasContainer.style.cursor = 'grab';
            });

            canvasContainer.addEventListener('wheel', (e) => {
                if (e.target.closest('.card')) {
                    e.stopPropagation();
                } else {
                    const mouseX = (e.clientX - canvas.getBoundingClientRect().left) / zoom;
                    const mouseY = (e.clientY - canvas.getBoundingClientRect().top) / zoom;
                    if (e.deltaY < 0) {
                        zoomIn();
                    } else {
                        zoomOut();
                    }
                    offsetX = 0;
                    offsetY = 0;
                    applyZoom();
                }
            });

            loadLayoutsFromCookies();
            drawConnections();
            fetchModels();
        }

        function showSaveLayoutPopup() {
            document.getElementById('save-layout-popup').style.display = 'block';
        }

        function saveLayout() {
            const layoutName = document.getElementById('layout-name').value.trim();
            if (!layoutName) return;

            const layoutData = {
                cards: cards.map(card => ({
                    type: card.querySelector('.card-header').classList.contains('llm') ? 'llm' : 'prompt',
                    left: card.style.left,
                    top: card.style.top,
                    model: card.dataset.model || '',
                    prompt: card.dataset.prompt || '',
                    message: card.querySelector('.message-area') ? card.querySelector('.message-area').value : ''
                })),
                connections: connections.map(conn => ({
                    from: {
                        cardIndex: cards.indexOf(conn.from.closest('.card')),
                        pointClass: Array.from(conn.from.classList).find(cls => cls.includes('-point'))
                    },
                    to: {
                        cardIndex: cards.indexOf(conn.to.closest('.card')),
                        pointClass: Array.from(conn.to.classList).find(cls => cls.includes('-point'))
                    }
                }))
            };

            const layouts = JSON.parse(getCookie('layouts') || '{}');
            layouts[layoutName] = layoutData;
            setCookie('layouts', JSON.stringify(layouts), 365);

            updateLayoutList();
            document.getElementById('save-layout-popup').style.display = 'none';
        }

        function loadLayout(name) {
            if (!name) return;

            const layouts = JSON.parse(getCookie('layouts') || '{}');
            const layout = layouts[name];
            if (!layout) return;

            clearTable();

            layout.cards.forEach(cardData => {
                const card = document.createElement('div');
                card.className = 'card';
                card.style.left = cardData.left;
                card.style.top = cardData.top;
                card.dataset.model = cardData.model;
                card.dataset.prompt = cardData.prompt;
                card.dataset.inputsReceived = 0;
                card.dataset.expectedInputs = 0;
                card.dataset.responses = '';

                const cardHeaderClass = cardData.type === 'llm' ? 'llm' : 'prompt';
                const cardHeaderContent = cardData.type === 'llm' ? `
                    <label for="modelSelect${cards.length}">Model</label>
                    <select id="modelSelect${cards.length}" onchange="updateCardModel(this)">
                        ${modelList.map(model => model !== 'NAME' ? `<option value="${model}" ${model === cardData.model ? 'selected' : ''}>${model}</option>` : '').join('')}
                    </select>
                    <textarea class="prompt-area" placeholder="Enter prompt">${cardData.prompt}</textarea>
                    <textarea class="message-area" placeholder="Enter your message">${cardData.message}</textarea>
                    <button onclick="sendMessage(this.parentNode.parentNode)">Send</button>
                    <div class="response-area"></div>
                 ` : `
                    <input type="text" class="prompt-input" placeholder="Enter prompt" value="${cardData.prompt}">
                    <input type="text" class="message-input" placeholder="Enter message" value="${cardData.message}">
                    <button onclick="sendPrompt(this.parentNode.parentNode)">Send</button>
                `;

                card.innerHTML = `
                    <div class="card-header ${cardHeaderClass}" onmousedown="startDragCard(event, this)">
                        <span class="card-title">${cardData.type === 'llm' ? 'LLM Card' : 'Prompt Card'} ${cards.length + 1}</span>
                        <div class="gear-icon" onclick="showCardSettingsPopup(this.parentNode.parentNode)">âš™</div>
                        <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                    </div>
                    <div class="card-body">
                        ${cardHeaderContent}
                    </div>
                    <div class="connection-point input-point top-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                    <div class="connection-point output-point top-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                    <div class="connection-point input-point bottom-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                    <div class="connection-point output-point bottom-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                    <div class="connection-point input-point left-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                    <div class="connection-point output-point left-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                    <div class="connection-point input-point right-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                    <div class="connection-point output-point right-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                    <div class="resize-button" onmousedown="startResize(event, this)"></div>
                `;

                canvas.appendChild(card);
                cards.push(card);
            });

            layout.connections.forEach(connData => {
                const from = cards[connData.from.cardIndex].querySelector(`.${connData.from.pointClass}`);
                const to = cards[connData.to.cardIndex].querySelector(`.${connData.to.pointClass}`);
                const connection = {
                    from,
                    to
                };
                connections.push(connection);
            });

            updateExpectedInputs();
            drawConnections();
        }

        function deleteLayout(name) {
            if (!name) return;

            const layouts = JSON.parse(getCookie('layouts') || '{}');
            delete layouts[name];
            setCookie('layouts', JSON.stringify(layouts), 365);

            updateLayoutList();
        }

        function updateLayoutList() {
            const layouts = JSON.parse(getCookie('layouts') || '{}');
            const layoutList = document.getElementById('layout-list');
            layoutList.innerHTML = '';

            Object.keys(layouts).forEach(name => {
                const listItem = document.createElement('li');
                listItem.className = 'layout-list-item';
                listItem.innerHTML = `
                    <span>${name}</span>
                    <div>
                        <button onclick="loadLayout('${name}')">Load</button>
                        <button onclick="deleteLayout('${name}')">Delete</button>
                    </div>
                `;
                layoutList.appendChild(listItem);
            });
        }

        function loadLayoutsFromCookies() {
            updateLayoutList();
        }

        function setCookie(name, value, days) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = name + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/';
        }

        function getCookie(name) {
            return document.cookie.split('; ').reduce((r, v) => {
                const parts = v.split('=');
                return parts[0] === name ? decodeURIComponent(parts[1]) : r;
            }, '');
        }

        initialize();
    </script>
</body>
</html>
